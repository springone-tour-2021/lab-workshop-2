# Deploy Color Application To Kubernetes - Step 2

Now that you have built and published the application images, you can attempt to deploy them to Kubernetes.
Each image will be deployed using a Kubernetes `deployment` resource.
The deployment creates one or more pods, each with a running instance of the image (aka a container) of the corresponding application.
Each app will also need a Kubernetes `service` resource, which will load balance requests across all instances of a particular pod.
The deployment and service resources will be defined declaratively using manifests (yaml files).

## Create Deployment Manifests

Create the manifest for the `deployment` of each application.
For now, you will start with a single color instance (`blue`).
Use the `kubectl` CLI with the option `--dry-run=client` to generate the yaml without applying it to Kubernetes.
```execute-1
mkdir -p k8s

kubectl create deployment blueorgreen \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/blueorgreen-deployment.template

kubectl create deployment blueorgreenfrontend \
            --image $REGISTRY_HOST/color-app/blueorgreenfrontend \
            -o yaml --dry-run=client > k8s/frontend-deployment.yaml

kubectl create deployment blueorgreengateway \
            --image $REGISTRY_HOST/color-app/blueorgreengateway \
            -o yaml --dry-run=client > k8s/gateway-deployment.yaml

kubectl create deployment blueorgreenauthgateway \
            --image $REGISTRY_HOST/color-app/authgateway \
            -o yaml --dry-run=client > k8s/authgateway-deployment.yaml
```

List all of the files you just created.
```execute-1
ls -l k8s/
```

Your output should look like this.
```
-rw-r--r-- 1 eduk8s root 539 May  7 01:47 authgateway-deployment.yaml
-rw-r--r-- 1 eduk8s root 509 May  7 01:47 blueorgreen-deployment.template
-rw-r--r-- 1 eduk8s root 543 May  7 01:47 frontend-deployment.yaml
-rw-r--r-- 1 eduk8s root 537 May  7 01:47 gateway-deployment.yaml
```

## Configuration: Auth Gateway, Routing Gateway, Frontend

Recall that in the previous lab, you added configuration to the common `application.yml` file for Kubernetes deployments.
Review the file now.
```editor:select-matching-text
file: ~/color-app/config-files/application.yml
text: "on-cloud-platform"
before: 3
after: 11
```

To maintain this configuration file external to the apps, you can mount it as a ConfigMap.

Create a ConfigMap from the common `application.yml` file.
```execute-1
kubectl create configmap application-config \
        --from-file=config-files/application.yml \
        -o yaml --dry-run=client > k8s/application-configmap.yaml
```

Review the resulting file.
```execute-1
cat k8s/application-configmap.yaml
```

Mount the ConfigMap as a container volume mount in each deployment spec.

Start with the Auth Gateway deployment manifest.
First create a volume.
```editor:insert-value-into-yaml
file: ~/color-app/k8s/authgateway-deployment.yaml
path: spec.template.spec
value:
      volumes:
        - name: config-volume
          configMap:
            name: application-config
```

Then, mount the volume on the container.
If you mount the volume at `/workspace/config/`, for example, Spring Boot will find this configuration by default and load it as usual.
```editor:insert-value-into-yaml
file: ~/color-app/k8s/authgateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        volumeMounts:
          - name: config-volume
            mountPath: /workspace/config
```

Do the same for the Routing Gateway and Frontend.
```editor:insert-value-into-yaml
file: ~/color-app/k8s/gateway-deployment.yaml
path: spec.template.spec
value:
      volumes:
        - name: config-volume
          configMap:
            name: application-config
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/gateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        volumeMounts:
          - name: config-volume
            mountPath: /workspace/config
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/frontend-deployment.yaml
path: spec.template.spec
value:
      volumes:
        - name: config-volume
          configMap:
            name: application-config
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/frontend-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        volumeMounts:
          - name: config-volume
            mountPath: /workspace/config
```

## Configuration: Backend

The backend service will use the same ConfigMap as the other apps, but it also has additional configuration specified in the application-specific file.
Take a moment to review this file.
```editor:open-file
file: ~/color-app/config-files/blueorgreen.yml
```

These configurations will cause each app to start on a different port.
On Kubernetes, this is not necessary, and in fact would only complicate configuration management.
You can remove the `server.port` settings from this file, or you can set the ports to `8080` on Kubernetes.
The latter approach maintains back-compatibility with non-cloud deployments.

Add configuration to set the port to 8080 on Kubernetes:
```editor:append-lines-to-file
file: ~/color-app/config-files/blueorgreen.yml
text: |
        ---
        spring:
          config:
            activate:
              on-cloud-platform: "kubernetes"
        server:
          port: 8080
```

Creating a ConfigMap from `blueorgreen.yml`.
```execute-1
kubectl create configmap blueorgreen-config \
        --from-file=application-blueorgreen.yml=config-files/blueorgreen.yml \
        -o yaml --dry-run=client > k8s/blueorgreen-configmap.yaml
```

Review the resulting file.
```execute-1
cat k8s/blueorgreen-configmap.yaml
```

Add both ConfigMaps using a Volume in the backend service manifest template.
```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.spec
value:
      volumes:
        - name: config-volume
          projected:
            sources:
            - configMap:
                name: application-config
            - configMap:
                name: blueorgreen-config
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.spec.containers.[0]
value:
        volumeMounts:
          - name: config-volume
            mountPath: /workspace/config
```

### Liveness & Readiness Probes

It is good practice to add liveness and readiness probes to our
deployments to allow Kubernetes to know when the app is up and when it
is ready to start receiving traffic.

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.spec.containers.[0]
value:
        readinessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/readiness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.spec.containers.[0]
value:
        livenessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/liveness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/frontend-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        readinessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/readiness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/frontend-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        livenessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/liveness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/gateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        readinessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/readiness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/gateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        livenessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/liveness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/authgateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        readinessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/readiness
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/authgateway-deployment.yaml
path: spec.template.spec.containers.[0]
value:
        livenessProbe:
          initialDelaySeconds: 30
          httpGet:
            port: 8080
            path: /actuator/health/liveness
```

## Templating The `bluegreenservice` Deployment

The file `blueorgreen-deployment.template` will act as a template we can use to create deployment manifests for the various Color Apps.
We need to template this deployment manifest in two places:

1. The name of the deployment
2. The Spring Boot profile we want to activate

Execute the following `sed` command to replace the `metadata.name` property
in the manifest with the template `$COLOR`.

```execute-1
sed -i '0,/name: blueorgreen/{s/name: blueorgreen/name: $COLOR/}' k8s/blueorgreen-deployment.template
```

To activate the Spring Boot profile for the color we can set the environment
variable `SPRING_PROFILES_ACTIVE` in the container when it starts on Kubernetes.
> Note: Notice that we are adding `blueorgreen` as an additional profile.
> This will enable Spring Boot to automatically use a properties file called application-blueorgreen.yml.
> We will use this naming convention when we mount `config-files/blueorgreen.yml`.

Add the following templated environment variable to the manifest to set the active profiles.
```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.spec.containers[0]
value:
    env:
    - name: SPRING_PROFILES_ACTIVE
      value: blueorgreen,$COLOR
```

In addition, we are going to add a label to our deployments called `hint` indicating whether a service is a premium service or not.
This will allow our Kubernetes service definition that we will create in the next section to select the appropriate services.
This will also need to be templated depending on the `blueorgreen` service we are deploying.

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: metadata.labels
value:
    hint: $TYPE
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.selector.matchLabels
value:
    hint: $TYPE
```

```editor:insert-value-into-yaml
file: ~/color-app/k8s/blueorgreen-deployment.template
path: spec.template.metadata.labels
value:
    hint: $TYPE
```

Now we can substitute the variables in this template using the `envsubst` command line
utility and generate deployment manifests for each of the Color Apps.

```execute-1
COLOR=blue
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/blue-deployment.yaml

COLOR=green
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/green-deployment.yaml

COLOR=yellow
TYPE=premium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/yellow-deployment.yaml

COLOR=slowgreen
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/slowgreen-deployment.yaml
```

Take a moment to review one of the files created.
```editor:open-file
file: ~/color-app/k8s/blue-deployment.yaml
```

## Create Service Manifests

First lets create 2 services for our premium and non-premium services.
Since we need to customize these service definitions we have supplied the entire service definitions for you as opposed to using `kubectl` to create them.
Click the action item below to create the service definitions for the `blueorgreen` services.

```editor:append-lines-to-file
file: ~/color-app/k8s/blueorgreen-service.yaml
text: |
        apiVersion: v1
        kind: Service
        metadata:
          creationTimestamp: null
          labels:
            app: blueorgreen
            hint: nonpremium
          name: blueorgreen-nonpremium
        spec:
          ports:
          - name: 80-8080
            port: 80
            protocol: TCP
            targetPort: 8080
          selector:
            app: blueorgreen
            hint: nonpremium
          type: ClusterIP
        status:
          loadBalancer: {}
        ---
        apiVersion: v1
        kind: Service
        metadata:
          creationTimestamp: null
          labels:
            app: blueorgreen
            hint: premium
          name: blueorgreen-premium
        spec:
          ports:
          - name: 80-8080
            port: 80
            protocol: TCP
            targetPort: 8080
          selector:
            app: blueorgreen
          type: ClusterIP
        status:
          loadBalancer: {}
```

Use the same "dry-run" approach as above to create the service manifests without applying them to Kubernetes.

```execute-1

kubectl create service clusterip blueorgreenfrontend \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/frontend-service.yaml

kubectl create service clusterip blueorgreengateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/gateway-service.yaml

kubectl create service clusterip blueorgreenauthgateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/authgateway-service.yaml
```

List the service manifest file you just created.
```execute-1
ls -l k8s/ | grep service
```

## Create An Ingress For The Auth Gateway

We need a way to access the authgateway app from a browser, so we must expose the service via an ingress.
Create a new ingress using the following action.

```editor:append-lines-to-file
file: ~/color-app/k8s/authgateway-ingress.yaml
text: |
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: blueorgreenauthgateway
          labels:
            app: blueorgreenauthgateway
        spec:
          rules:
          - host: blueorgreenauthgateway-{{ session_namespace }}.{{ ingress_domain }}
            http:
              paths:
              - path: "/"
                pathType: Prefix
                backend:
                  service:
                    name: blueorgreenauthgateway
                    port: 
                      number: 80
```


## Deploying The Applications

To `watch` the deployments happen run the following command

```execute-2
watch -n 1 kubectl get all
```

To deploy everything to Kubernetes run the following command

```execute-1
kubectl apply -Rf ~/color-app/k8s
```

Click the action button below to open the Auth Gateway in your browser and test the application.
You should be able to log in with the user `user` and the password `pw` and only see the colors blue, green, or red (for the `slowgreen` service.)

```dashboard:open-url
url: http://blueorgreenauthgateway-{{ session_namespace }}.{{ ingress_domain }}
```

Now log out by going to

```dashboard:open-url
url: http://blueorgreenauthgateway-{{ session_namespace }}.{{ ingress_domain }}/logout
```

Then log back in with the user `premium` and the password `pw`.
Now in addition to the colors you saw with the user `user` you
should see the color yellow.

Exit the watch command by running the following action command.

```terminal:interrupt
session: 2
```