# Run Locally

In this section, you will run the application in the workshop terminal to see the application in action.

## Start Config Server And Eureka Discovery Server
The applications are configured to connect to a Spring Cloud Config Server and a Eureka Discovery Server running locally in order to retrieve their configuration and find one another.

Use the [Spring Cloud CLI](https://spring.io/projects/spring-cloud-cli) to start an instance of each.
> Note: The following startup commands will run the Java processes in the background, so you won't see the app startup log appear in the terminal window.
> Instead, any logging will be redirected to a file.
```execute-1
mkdir -p logs
spring cloud configserver eureka > logs/run-spring-cloud.log 2>&1 </dev/null &
```

Run the following command repeatedly until you see output confirming that Config Server and Eureka have started.
```execute-1
grep "started on port" logs/run-spring-cloud.log
```

The output should look like this, indicating Config Server listening on port 8888 and Eureka listening on port 8761.
```
2021-05-07 01:18:19.153  INFO 4779 --- [       Thread-0] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
2021-05-07 01:18:27.420  INFO 4779 --- [       Thread-5] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8761 (http) with context path ''
```

Once Eureka has started, you can access its dashboard:
```dashboard:open-url
url: http://{{ session_namespace }}-eureka.{{ ingress_domain }}/
```

## Start Backend Apps

Next, build and start a Backend app instance using the `blue` profile.
> Note: In this workshop environment, we are choosing to use `java -jar` rather than `mvn spring-boot:run` to start the apps locally so that we can control the memory utilization.
```execute-1
cd blueorgreenservice && \
   ./mvnw package -DskipTests \
        > ../logs/build-blueorgreen.log 2>&1 </dev/null && \
   java -Xmx128M -Dspring.profiles.active=blue \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-blue.log 2>&1 </dev/null &
```

Run the following command repeatedly until you see a line of output confirming that the blue instance has started.
```execute-1
grep "started on port" logs/run-blue.log
```

The output should look like this.
```
2021-04-20 21:58:43.563  INFO 798 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8181 (http) with context path ''
```

As you can see in the log output, `blue` started on port 8181.

Send a request to the `blue` app.

```execute-1
http -b :8181
```

The response will look like this.
```
{
    "id": "blue"
}
```

Refresh the Eureka dashboard in your browser until you see that the `blue` app has registered itself.
It uses the application name `BLUEORGREEN`.

> Picture for reference of the blue app registered in Eureka Server:
![alt_text](images/eureka-local-blue-app.png "Eureka registration")

Start three more Backend instances: green, slowgreen, and yellow.
The profiles are configured such that each will run on a different port to prevent conflicts on the same host.
```execute-1
cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=green \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-green.log 2>&1 </dev/null &

cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=slowgreen \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-slowgreen.log 2>&1 </dev/null &

cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=yellow \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-yellow.log 2>&1 </dev/null &
```

Refresh the Eureka dashboard again until you see all four Backend instances registered.
You should see an Application named `BLUEORGREEN` with four endpoints under the `Status` column, each with a unique port number.

> Picture for reference of Backend apps registered in Eureka Server:
![alt_text](images/eureka-local-backend-apps.png "Eureka registration")

Send a request to `slowgreen`. Notice that it takes 5 seconds to return.
```execute-1
time http :6060
```

Next, start the Frontend, the Routing Gateway, and the Auth Gateway.
```execute-1
cd blueorgreenfrontend && \
   ./mvnw package -DskipTests \
        > ../logs/build-frontend.log 2>&1 </dev/null && \
   java -Xmx128M -Dspring.profiles.active=local \
        -jar target/blueorgreenfrontend-0.0.1-SNAPSHOT.jar \
        > ../logs/run-frontend.log 2>&1 </dev/null &
    
cd blueorgreengateway && \
   ./mvnw package -DskipTests \
        > ../logs/build-gateway.log 2>&1 </dev/null && \
   java -Xmx128M \
        -jar target/blueorgreengateway-0.0.1-SNAPSHOT.jar \
        > ../logs/run-gateway.log 2>&1 </dev/null &

cd authgateway && \
   ./mvnw package -DskipTests \
        > ../logs/build-authgateway.log 2>&1 </dev/null && \
   java -Xmx128M \
        -jar target/authgateway-0.0.1-SNAPSHOT.jar \
        > ../logs/run-authgateway.log 2>&1 </dev/null &
```

Refresh the Eureka dashboard again until you see all apps registered.
You should see four distinct application names in the `APPLICATION` column.

> Picture for reference of all apps registered in Eureka Server:
![alt_text](images/eureka-local-all-apps.png "Eureka registration")

## Test The Color Application

Test the app by opening the Auth Gateway endpoint in the browser.
```dashboard:open-url
url: http://{{ session_namespace }}-authgateway.{{ ingress_domain }}/
```

Notice that you are automatically routed to a login page.

Log in using username `user` and password `pw`.

After logging in, refresh the page several times.
You should see the color rotate between blue, green, and red.
You should **not** see yellow.

Notice that green never takes 5 seconds to appear.
Instead, each time `slowgreen` is called, the color `red` appears after a 1-second delay.

Log out of the application by typing `/logout` at the end of the URL or by clicking on the following action block:
```dashboard:open-url
url: http://{{ session_namespace }}-authgateway.{{ ingress_domain }}/logout
```

Log in again using username `premium` and password `pw`.
Refresh the page several times.
You should now see yellow amongst the colors.

## Understand Color Application Behavior

##### Authentication & Authorization
Since this is a local deployment, the apps are reachable at their `host:port` address.
However, the intention is that, in a production environment, you would expose only the Auth Gateway publically, 
and the rest of the apps would only be reachable internally.

The Auth Gateway uses Spring Cloud Security to apply a security filter, redirecting the user to a login page if the user has not yet been authenticated.
Typically, the Auth Gateway would be integrated with an Identity Management system. However, to keep things simple in this demo app, credentials for two users (`user/pw` and `premium/pw`) are hard-coded in the Auth Gateway.
Once a user has successfully authenticated, the Auth Gateway enriches the request headers with authorization information (aka `premium` or `nonpremium`) and forwards requests to the `blueorgreengateway`. The `blueorgreengateway` then routes requests to the remaining applications.

##### Circuit Breaker And Fallback Configuration
The `blueorgreengateway` will wait about one second for a color service instance to return.
If it does not receive a response, it times out and resorts to a fallback action, which returns a hard-coded value of `red`.

Take a look at the code that defines this behavior.
```editor:select-matching-text
file: ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
text: .filters(this::circuitBreaker)
```

Look down the page to see the `circuitBreaker` method that configures the fallback, and even further down to see the `fallbackColor` method that returns `red`.

##### Externalized Configuration
Upon startup, each app communicates with the Config Server to obtain its respective configuration.
The Config Server retrieves all configuration files from the [`config-files` directory on GitHub](https://github.com/springone-tour-2021/gateway-s1p-2018/tree/master/config-files).
 How does the Config Server know where to get the full set of config files?
 You can see this in the Config Server's properties file:
 ```editor:select-matching-text
 file: ~/color-app/configserver.yml
 text: uri
 before: 1
 after: 1
 ```

The Config Server then uses each app's `spring.application.name` and its profile (e.g. `blue`) to filter the appropriate set of configuration parameters for a given app instance.
For example, for the `blue` app, `spring.application.name=blueorgreen` and `profiles=blue`, so the configuration is created using an overlay of the following files: `config-files/application.yml` and parts of `config-files/blueorgreen.yml`.
You can peruse the files locally since they are included in the cloned repo.
Use the left-hand frame in the Editor to switch between files.
 ```editor:select-matching-text
 file: ~/color-app/config-files/blueorgreen.yml
 text: blue
 before: 0
 after: 2
 ```

##### Service Discovery & Premium Configuration
For app-to-app communication, when an app needs to make an HTTP request to another app it uses Eureka to look up the endpoint of the destination app.

When the `blueorgreengateway` looks up the `blueorgreenservice`, it also checks for extra metadata.
Specifically, it checks for metadata indicating if the service is `premium` or `nonpremium`.
Take a look at the `blueorgreen.yml` that should be open in your Editor from the previous action block.
Notice the default configuration property at the top of the file: `eureka.instance.metadataMap.hint: nonpremium`.
Also notice that the `yellow` instance sets the value to `premium`.

You can verify that this metadata gets registered in Eureka using the following command, which retrieves details on all instances, and then filters the results using the key word `premium`.
Notice that only the instance running on port 8282 (`yellow`) contains metadata containing the `premium` key word.

```execute-1
http -b :8761/eureka/apps | grep -B 2 -A 2 "<hint>premium</hint>"
```

Your output will look like this.
```xml
      <metadata>
        <instanceId>blueorgreen:8282</instanceId>
        <hint>premium</hint>
        <management.port>8282</management.port>
      </metadata>
```

The `blueorgreengateway` uses the authorization information in the request header (added by the Auth Gateway) together with this metadata obtained from Eureka to determine whether to include the `yellow` endpoint in the load balancing for a given request user.

## Stop The Applications

Stop all the locally running applications.
```execute-1
kill $(pidof java)
```

## Next Steps
In this exercise, you deployed and tested the Color Application locally at your terminal.
You should now have a good understanding of how the app works and of the expected behavior.

The Color Application has been working well.
However, managing this application at scale on traditional infrastructure has become cumbersome.
Moving the application to Kubernetes can reduce the operational burden.
In the next sections, we will explore a couple of approaches for moving the Color Application to Kubernetes and discuss the benefits and challenges.
